<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Matthew Leonawicz</title>
    <link>/post/</link>
    <description>Recent content in Posts on Matthew Leonawicz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Matthew Leonawicz</copyright>
    <lastBuildDate>Thu, 19 Apr 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>tabr package for guitar tablature now on CRAN</title>
      <link>/post/tabr-package-for-guitar-tablature-now-on-cran/</link>
      <pubDate>Thu, 19 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/tabr-package-for-guitar-tablature-now-on-cran/</guid>
      <description>

&lt;p style=&#34;text-align:center;&#34;&gt;
&lt;a href=&#34;https://github.com/leonawicz/tabr&#34;&gt;&lt;img src=&#34;https://github.com/leonawicz/tabr/blob/master/data-raw/tabr.png?raw=true&#34; width=&#34;40%&#34;&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/leonawicz/tabr&#34; target=&#34;_blank&#34;&gt;tabr&lt;/a&gt; package for creating guitar tablature (&amp;ldquo;tabs&amp;rdquo;) from R code is now available on CRAN. &lt;code&gt;tabr&lt;/code&gt; provides programmatic music notation and a wrapper around &lt;a href=&#34;http://lilypond.org/&#34; target=&#34;_blank&#34;&gt;LilyPond&lt;/a&gt; for creating quality guitar tablature.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tabr&lt;/code&gt; offers functions for describing and organizing musical structures and wraps around the LilyPond backend. LilyPond is an open source music engraving program for generating high quality sheet music based on markup syntax. &lt;code&gt;tabr&lt;/code&gt; generates files following the LilyPond markup syntax to be subsequently processed by LilyPond into sheet music.&lt;/p&gt;

&lt;p&gt;A standalone LilyPond (.ly) file can be created or the package can make a system call to LilyPond directly to render the guitar tablature output (pdf or png). While LilyPond caters to sheet music in general, &lt;code&gt;tabr&lt;/code&gt; is focused on leveraging it specifically for creating quality guitar tablature.&lt;/p&gt;

&lt;p&gt;While music can be quite complex and a full score will be much longer, something as simple as the following code snippet produces the music notation in the accompanying image.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;p(&amp;quot;r a2 c f d a f c4&amp;quot;, &amp;quot;4 8*6 1&amp;quot;) %&amp;gt;% track %&amp;gt;% score %&amp;gt;% tab(&amp;quot;out.pdf&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p style=&#34;text-align:center;&#34;&gt;
&lt;img src=&#34;https://github.com/leonawicz/tabr/blob/master/data-raw/staff_with_code.png?raw=true&#34; width=&#34;100%&#34;&gt;
&lt;/p&gt;

&lt;h2 id=&#34;functionality-and-support&#34;&gt;Functionality and support&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;tabr&lt;/code&gt; package offers the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Render guitar tablature and sheet music to pdf or png.&lt;/li&gt;
&lt;li&gt;Write accompanying MIDI files that can respect repeat notation and transposition in the sheet music (under reasonable conditions).&lt;/li&gt;
&lt;li&gt;Support tablature for other string instruments besides guitar such as bass or banjo.&lt;/li&gt;
&lt;li&gt;Support for instruments with different numbers of strings.&lt;/li&gt;
&lt;li&gt;Support for arbitrary instrument tuning.&lt;/li&gt;
&lt;li&gt;Offers inclusion (or exclusion) of formal music staves above tab staves, such as treble and bass clef staves for complete rhythm and timing information.&lt;/li&gt;
&lt;li&gt;Track-specific setup for features like instrument type, tuning and supplemental music staves.&lt;/li&gt;
&lt;li&gt;Provide common notation such as slide, bend, hammer on, pull off, slur, tie, staccato, dotted notes, visible and silent rests.&lt;/li&gt;
&lt;li&gt;Allows arbitrary tuplet structure.&lt;/li&gt;
&lt;li&gt;Above-staff text annotation.&lt;/li&gt;
&lt;li&gt;Percent and volta repeat section notation.&lt;/li&gt;
&lt;li&gt;Note transposition.&lt;/li&gt;
&lt;li&gt;Staff transposition.&lt;/li&gt;
&lt;li&gt;Multiple voices per track and multiple tracks per score.&lt;/li&gt;
&lt;li&gt;Chord symbols above staff&lt;/li&gt;
&lt;li&gt;Chord fretboard diagrams and chord chart at top of score.&lt;/li&gt;
&lt;li&gt;Rich set of layout control options covering settings from score attributions to font size.&lt;/li&gt;
&lt;li&gt;Optional alternative input format allowing the user to provide string/fret combinations (along with key signature and instrument tuning) to map to pitch.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that MIDI support and string/fret alternative input format support are not prioritized in ongoing &lt;code&gt;tabr&lt;/code&gt; development. These are considered tangential extra features in &lt;code&gt;tabr&lt;/code&gt; that fall outside the general scope and intent of the package.&lt;/p&gt;

&lt;h2 id=&#34;basic-example&#34;&gt;Basic example&lt;/h2&gt;

&lt;p&gt;A brief example below highlights the general workflow.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Define a musical phrase with &lt;code&gt;phrase&lt;/code&gt; or the shorthand alias &lt;code&gt;p&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Add the phrase to a &lt;code&gt;track&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Add the track to a &lt;code&gt;score&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Render the score to pdf with &lt;code&gt;tab&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;constructing-a-musical-phrase&#34;&gt;Constructing a musical phrase&lt;/h2&gt;

&lt;p&gt;A phrase here does not require a strict definition. Think of it as the smallest piece of musical structure you intend to string together. The first argument to &lt;code&gt;phrase&lt;/code&gt; is a string describing notes of a specific pitch (or rests: &amp;ldquo;r&amp;rdquo;), separated in time by spaces. For chords, just remove spaces to indicate simultaneous notes. Integers are appended to indicate the octave number so that the pitch is unique. For example, a rest followed by a sequence of notes might be given by &lt;code&gt;notes = &amp;quot;r a2 c3 f3 d3 a3 f3&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The second argument is a similar string giving note metadata. In this example there is nothing to add but the time durations. Whole notes taking up an entire measure of music are given by 1, half notes by 2, quarter notes 4, eighth notes 8, and so on. To specify a quarter note rest followed by a sequence of eighth notes, use &lt;code&gt;info = &amp;quot;4 8 8 8 8 8 8&amp;quot;&lt;/code&gt;. This basic example does not require specifying additional note information such as dotted notes for different fractions of time, staccato notes, ties/slurs, slides, bends, hammer ons and pull offs, etc. These specifications are currently available in &lt;code&gt;tabr&lt;/code&gt; to varying degrees of development and are covered in the vignette tutorials.&lt;/p&gt;

&lt;p&gt;The third argument, &lt;code&gt;string&lt;/code&gt;, is optional but generally important for guitar tablature. In similar format, it specifies the strings of the guitar on which notes are played. Providing this information fixes the fret-string combinations so that LilyPond does not have to guess what position on the neck of the guitar to play a specific note. An inability to specify this in various tablature notation software (or laziness by the user), is a common cause of inaccurate tabs scouring the internet, where even when the notes are correct they are written in the tab suggesting they be played in positions no one would sensibly use. Note that the &lt;code&gt;x&lt;/code&gt; shown below is just a placeholder indicating no need to specify a string for the quarter note rest.&lt;/p&gt;

&lt;p&gt;The example below employs a couple shortcuts to further reduce typing, using the &lt;code&gt;*&lt;/code&gt; in-string expansion operator to avoid typing a long series of eighth notes. It also drops explicit reference to octave number three since this central octave is the default octave in LilyPond. While explicit string numbers are not needed for this example, they are provided anyway for full context.&lt;/p&gt;

&lt;h2 id=&#34;score-metadata-and-accessing-lilypond&#34;&gt;Score metadata and accessing LilyPond&lt;/h2&gt;

&lt;p&gt;Finally, specify some song metadata to reproduce the original staff: the key of D minor, common time, and the tempo. If LilyPond is installed on your system (and added to your system PATH variable on Windows systems), &lt;code&gt;tab&lt;/code&gt; should call it successfully. Alternatively, on Windows, it can be added explicitly by calling &lt;code&gt;tabr_options&lt;/code&gt;. This option to specify the LilyPond path is still available on other systems. An example of this is commented out below.&lt;/p&gt;

&lt;h2 id=&#34;r-code&#34;&gt;R code&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(tabr)
# path &amp;lt;- &#39;C:/Program Files (x86)/LilyPond/usr/bin/lilypond.exe&#39;
# tabr_options(lilypond = path)

song &amp;lt;- p(&amp;quot;r a2 c f d a f&amp;quot;, &amp;quot;4 8*6&amp;quot;, &amp;quot;x 5 5 4 4 3 4&amp;quot;) %&amp;gt;% track %&amp;gt;% score
tab(song, &amp;quot;out.pdf&amp;quot;, key = &amp;quot;dm&amp;quot;, time = &amp;quot;4/4&amp;quot;, tempo = &amp;quot;4 = 120&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#&amp;gt; #### Engraving score to phrase.pdf ####
#&amp;gt; GNU LilyPond 2.18.2
#&amp;gt; Processing `./phrase.ly&#39;
#&amp;gt; Parsing...
#&amp;gt; Interpreting music...
#&amp;gt; Preprocessing graphical objects...
#&amp;gt; Interpreting music...
#&amp;gt; MIDI output to `./phrase.mid&#39;...
#&amp;gt; Finding the ideal number of pages...
#&amp;gt; Fitting music on 1 page...
#&amp;gt; Drawing systems...
#&amp;gt; Layout output to `./phrase.ps&#39;...
#&amp;gt; Converting to `./phrase.pdf&#39;...
#&amp;gt; Success: compilation successfully completed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See the pdf result embedded at the &lt;a href=&#34;https://leonawicz.github.io/tabr/&#34; target=&#34;_blank&#34;&gt;tabr website&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;additional-context&#34;&gt;Additional context&lt;/h2&gt;

&lt;p&gt;Why LilyPond? LilyPond is an exceptional sheet music engraving program. It produces professional, high quality output. It is open source. It offers an access point for a programmatic approach to music notation. It is developed and utilized by a large community. Most GUI-based applications are WYSIWYG and force a greater limitation on what you can do and what it will look like after you do it. On the other hand, I have zero interest in writing LilyPond files. &lt;code&gt;tabr&lt;/code&gt; has made it more enjoyable, a bit less ugly, and enables me to stick with LilyPond for its quality as I try to shield myself from its native input structures. I&amp;rsquo;m sure there are far more LilyPond users who don&amp;rsquo;t mind it at all and have never heard of R; to each their own.&lt;/p&gt;

&lt;h2 id=&#34;limitations&#34;&gt;Limitations&lt;/h2&gt;

&lt;p&gt;There is far more that LilyPond can do that &lt;code&gt;tabr&lt;/code&gt; does not tap into. Instead of listing a million things, this is just to highlight an example of a critical feature that still has limited functionality in both &lt;code&gt;tabr&lt;/code&gt; and in LilyPond itself: LilyPond&amp;rsquo;s bend engraver. Rendering sheet music with quality string bend notation is quite difficult. This is an area that will benefit greatly from further development.&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;p&gt;There is a rich collection of vignette tutorials available at the tabr website.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leonawicz.github.io/tabr/&#34; target=&#34;_blank&#34;&gt;Complete package reference and function documentation&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing tabr: guitar tabs with R</title>
      <link>/post/introducing-tabr-guitar-tabs-with-r/</link>
      <pubDate>Mon, 19 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/introducing-tabr-guitar-tabs-with-r/</guid>
      <description>

&lt;p style=&#34;text-align:center;&#34;&gt;
&lt;a href=&#34;https://github.com/leonawicz/tabr&#34;&gt;&lt;img src=&#34;https://github.com/leonawicz/tabr/blob/master/data-raw/tabr_logo.png?raw=true&#34; width=&#34;100%&#34;&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;This post introduces a new R package I am working on called &lt;a href=&#34;https://github.com/leonawicz/tabr&#34; target=&#34;_blank&#34;&gt;tabr&lt;/a&gt; for creating guitar tablature (&amp;ldquo;tabs&amp;rdquo;) from R code. The &lt;code&gt;tabr&lt;/code&gt; package provides programmatic music notation and a wrapper around &lt;a href=&#34;http://lilypond.org/&#34; target=&#34;_blank&#34;&gt;LilyPond&lt;/a&gt; for creating quality guitar tablature.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tabr&lt;/code&gt; offers functions for describing and organizing musical structures and wraps around the LilyPond backend. LilyPond is an open source music engraving program for generating high quality sheet music based on markup syntax. &lt;code&gt;tabr&lt;/code&gt; generates files following the LilyPond markup syntax to be subsequently processed by LilyPond into sheet music.&lt;/p&gt;

&lt;p&gt;A standalone LilyPond (.ly) file can be created or the package can make a system call to LilyPond directly to render the guitar tablature output (pdf or png). While LilyPond caters to sheet music in general, &lt;code&gt;tabr&lt;/code&gt; is focused on leveraging it specifically for creating quality guitar tablature.&lt;/p&gt;

&lt;p&gt;While music can be quite complex and a full score will be much longer, something as simple as the following code snippet produces the music notation in the accompanying image.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;p(&amp;quot;r a2 c f d a f c4&amp;quot;, &amp;quot;4 8*6 1&amp;quot;) %&amp;gt;% track %&amp;gt;% score %&amp;gt;% tab(&amp;quot;out.pdf&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p style=&#34;text-align:center;&#34;&gt;
&lt;img src=&#34;https://github.com/leonawicz/tabr/blob/master/data-raw/staff_with_code.png?raw=true&#34; width=&#34;100%&#34;&gt;
&lt;/p&gt;

&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;

&lt;p&gt;You can install tabr from GitHub with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#39;devtools&#39;)
devtools::install_github(&amp;quot;leonawicz/tabr&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;basic-example&#34;&gt;Basic example&lt;/h2&gt;

&lt;p&gt;As a brief example, recreate the tablature shown in the &lt;code&gt;tabr&lt;/code&gt; logo, which is almost the same as the first measure in the code example above. It has a tiny bit more in the form of metadata and doesn&amp;rsquo;t take as many shortcuts, but it&amp;rsquo;s still short. Here are the steps.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Define a musical phrase with &lt;code&gt;phrase&lt;/code&gt; or the shorthand alias &lt;code&gt;p&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Add the phrase to a &lt;code&gt;track&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Add the track to a &lt;code&gt;score&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Render the score to pdf with &lt;code&gt;tab&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;constructing-a-musical-phrase&#34;&gt;Constructing a musical phrase&lt;/h2&gt;

&lt;p&gt;A phrase here does not require a strict definition. Think of it as the smallest piece of musical structure you intend to string together. The first argument to &lt;code&gt;phrase&lt;/code&gt; is a string describing notes of a specific pitch (or rests: &amp;ldquo;r&amp;rdquo;), separated in time by spaces. For chords, just remove spaces to indicate simultaneous notes. Integers are appended to indicate the octave number so that the pitch is unique. For example, a rest followed by a sequence of notes might be given by &lt;code&gt;notes = &amp;quot;r a2 c3 f3 d3 a3 f3&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The second argument is a similar string giving note metadata. In this example there is nothing to add but the time durations. Whole notes taking up an entire measure of music are given by 1, half notes by 2, quarter notes 4, eighth notes 8, and so on. To specify a quarter note rest followed by a sequence of eighth notes, use &lt;code&gt;info = &amp;quot;4 8 8 8 8 8 8&amp;quot;&lt;/code&gt;. This basic example does not require specifying additional note information such as dotted notes for different fractions of time, staccato notes, ties/slurs, slides, bends, hammer ons and pull offs, etc. These specifications are currently available in &lt;code&gt;tabr&lt;/code&gt; to varying degrees of development and are covered in the vignette tutorials.&lt;/p&gt;

&lt;p&gt;The third argument, &lt;code&gt;string&lt;/code&gt;, is optional but generally important for guitar tablature. In similar format, it specifies the strings of the guitar on which notes are played. Providing this information fixes the fret-string combinations so that LilyPond does not have to guess what position on the neck of the guitar to play a specific note. An inability to specify this in various tablature notation software (or laziness by the user), is a common cause of inaccurate tabs scouring the internet, where even when the notes are correct they are written in the tab suggesting they be played in positions no one would sensibly use. Note that the &lt;code&gt;x&lt;/code&gt; shown below is just a placeholder indicating no need to specify a string for the quarter note rest.&lt;/p&gt;

&lt;h2 id=&#34;score-metadata-and-accessing-lilypond&#34;&gt;Score metadata and accessing LilyPond&lt;/h2&gt;

&lt;p&gt;Finally, specify some song metadata to reproduce the original staff: the key of D minor, common time, and the tempo. If LilyPond is installed on your system (and added to your system PATH variable on Windows systems), &lt;code&gt;tab&lt;/code&gt; should call it successfully. Alternatively, on Windows, it can be added explicitly by calling &lt;code&gt;tabr_options&lt;/code&gt;. This option to specify the LilyPond path is still available on other systems. An example of this is commented out below.&lt;/p&gt;

&lt;h2 id=&#34;r-code&#34;&gt;R code&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(tabr)
# path &amp;lt;- &#39;C:/Program Files (x86)/LilyPond/usr/bin/lilypond.exe&#39;
# tabr_options(lilypond = path)

p1 &amp;lt;- p(&amp;quot;r a2 c3 f3 d3 a3 f3&amp;quot;, &amp;quot;4 8 8 8 8 8 8&amp;quot;, &amp;quot;x 5 5 4 4 3 4&amp;quot;)
track1 &amp;lt;- track(p1)
song &amp;lt;- score(track1)
tab(song, &amp;quot;phrase.pdf&amp;quot;, key = &amp;quot;dm&amp;quot;, time = &amp;quot;4/4&amp;quot;, tempo = &amp;quot;4 = 120&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#&amp;gt; #### Engraving score to phrase.pdf ####
#&amp;gt; GNU LilyPond 2.18.2
#&amp;gt; Processing `./phrase.ly&#39;
#&amp;gt; Parsing...
#&amp;gt; Interpreting music...
#&amp;gt; Preprocessing graphical objects...
#&amp;gt; Interpreting music...
#&amp;gt; MIDI output to `./phrase.mid&#39;...
#&amp;gt; Finding the ideal number of pages...
#&amp;gt; Fitting music on 1 page...
#&amp;gt; Drawing systems...
#&amp;gt; Layout output to `./phrase.ps&#39;...
#&amp;gt; Converting to `./phrase.pdf&#39;...
#&amp;gt; Success: compilation successfully completed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See the pdf result embedded at the &lt;a href=&#34;https://leonawicz.github.io/tabr/&#34; target=&#34;_blank&#34;&gt;tabr website&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;development-status-context-and-caveats&#34;&gt;Development status, context and caveats&lt;/h2&gt;

&lt;p&gt;First, why LilyPond? LilyPond is an exceptional sheet music engraving program. It produces professional, high quality output. It is open source. It offers an access point for a programmatic approach to music notation. It is developed and utilized by a large community. Most GUI-based applications are WYSIWYG and force a greater limitation on what you can do and what it will look like after you do it. On the other hand, I have zero interest in writing LilyPond files. &lt;code&gt;tabr&lt;/code&gt; has made it more enjoyable, a bit less ugly, and enables me to stick with LilyPond for its quality as I try to shield myself from its native input structures. I&amp;rsquo;m sure there are far more LilyPond users who don&amp;rsquo;t mind it at all and have never heard of R; to each their own.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;tabr&lt;/code&gt; package is in early development. Breaking changes could occur in a later version. Many capabilities are missing. Others are incompletely implemented. Others in the R developer community who are probably much better musicians than myself are welcome to contribute. This is the type of package that will only develop in response to specific needs of its contributor(s). There are many things that &lt;code&gt;tabr&lt;/code&gt; does not address at this stage of development. For example, &lt;code&gt;tabr&lt;/code&gt; assumes standard guitar tuning. It has no ability to recognize or handle non-standard tunings or instruments like bass with a different number of strings. There are essentially countless other aspects of music notation available in LilyPond that &lt;code&gt;tabr&lt;/code&gt; does not wrap around. The aim is not to do it all, but certainly to do much more than is currently in place.&lt;/p&gt;

&lt;p&gt;I am not an expert in music theory, or in music notation and transcription, or in LilyPond. In fact, my skill in music notation is ironically low enough that I do not find it any more challenging or an impediment to describe a song in R code rather than to just tab it out by hand. The main intent with &lt;code&gt;tabr&lt;/code&gt;, however, is simply to be able to generate markup files that LilyPond accepts and understands, without having to write that markup directly.&lt;/p&gt;

&lt;p&gt;Finally, there are nonetheless limitations to LilyPond itself. It has been developed for sheet music in general and guitar tablature features were added as a relative afterthought. There are plenty of features I have not yet developed R wrappers around. Then there are other features like string bending that are technically available, but not fully developed yet on the LilyPond side either. Case in point, LilyPond&amp;rsquo;s bend engraver is still under development; specifying something as common as a bend-release-pull-off is, to put it mildly, challenging.&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leonawicz.github.io/tabr/&#34; target=&#34;_blank&#34;&gt;Complete package reference and function documentation&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mix ggplot2 graphs with your favorite memes. memery 0.4.2 released.</title>
      <link>/post/2018-02-09-mix-ggplot2-graphs-with-your-favorite-memes-memery-0-4-2-on-cran/</link>
      <pubDate>Tue, 13 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-02-09-mix-ggplot2-graphs-with-your-favorite-memes-memery-0-4-2-on-cran/</guid>
      <description>&lt;p&gt;Make memorable plots with memery. &lt;code&gt;memery&lt;/code&gt; is an R package that generates internet memes including superimposed inset graphs and other atypical features, combining the visual impact of an attention-grabbing meme with graphic results of data analysis. &lt;a href=&#34;https://cran.r-project.org/web/packages/memery/&#34;&gt;Version 0.4.2&lt;/a&gt; of &lt;code&gt;memery&lt;/code&gt; is now on CRAN. The latest development version and a package vignette are available on &lt;a href=&#34;https://github.com/leonawicz/memery&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;div id=&#34;changes-in-v0.4.2&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Changes in v0.4.2&lt;/h2&gt;
&lt;p&gt;This latest version of &lt;code&gt;memery&lt;/code&gt; includes a demo Shiny app.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(memery)
memeApp()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Animated gif support is now also included (example below). This relies on the &lt;code&gt;magick&lt;/code&gt; package and ImageMagick software, but this is optional and these libraries are not required for you to use &lt;code&gt;memery&lt;/code&gt; if you have no interest in animated gifs. For example, when launching the demo Shiny app, if you do not have these libraries installed on your system, the app launches in your browser in a simplified form. It will only accept png and jpg files as inputs and a default static image will be shown at startup. Alternatively, the app launches in full mode, will also accept gif inputs, and the default image shown is an animated gif. The only function in &lt;code&gt;memery&lt;/code&gt; that pertains to gifs is &lt;code&gt;meme_gif&lt;/code&gt;, which is distinct from the main package function, &lt;code&gt;meme&lt;/code&gt;. If you call &lt;code&gt;meme_gif&lt;/code&gt; without the supporting libraries, it simply prints a notification about this to the console.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;example-usage&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Example usage&lt;/h2&gt;
&lt;p&gt;Below is an example interleaving a semi-transparent ggplot2 graph between a meme image backdrop and overlying meme text labels. The &lt;code&gt;meme&lt;/code&gt; function will produce basic memes without needing to specify a number of additional arguments, but this is not the main purpose of the package. Adding a plot is then as simple as passing the plot to &lt;code&gt;inset&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;memery&lt;/code&gt; offers sensible defaults as well as a variety of basic templates for controlling how the meme and graph are spliced together. The example here shows how additional arguments can be specified to further control the content and layout. See the package &lt;a href=&#34;https://leonawicz.github.io/memery/articles/memery.html&#34;&gt;vignette&lt;/a&gt; for a more complete set of examples and description of available features and graph templates.&lt;/p&gt;
&lt;p&gt;Please do share your data analyst meme creations. Enjoy!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(memery)

# Make a graph of some data
library(ggplot2)
x &amp;lt;- seq(0, 2 * pi, length.out = 50)
panels &amp;lt;- rep(c(&amp;quot;Plot A&amp;quot;, &amp;quot;Plot B&amp;quot;), each = 50)
d &amp;lt;- data.frame(x = x, y = sin(x), grp = panels)
txt &amp;lt;- c(&amp;quot;Philosoraptor&amp;#39;s plots&amp;quot;, &amp;quot;I like to make plots&amp;quot;, &amp;quot;Figure 1. (A) shows a plot and (B) shows another plot.&amp;quot;)
p &amp;lt;- ggplot(d, aes(x, y)) + geom_line(colour = &amp;quot;cornflowerblue&amp;quot;, size = 2) + 
    geom_point(colour = &amp;quot;orange&amp;quot;, size = 4) + facet_wrap(~grp) + labs(title = txt[1], 
    subtitle = txt[2], caption = txt[3])

# Meme settings
img &amp;lt;- system.file(&amp;quot;philosoraptor.jpg&amp;quot;, package = &amp;quot;memery&amp;quot;)
lab &amp;lt;- c(&amp;quot;What to call my R package?&amp;quot;, &amp;quot;Hmm... What? raptr is taken!?&amp;quot;, &amp;quot;Noooooo!!!!&amp;quot;)
size &amp;lt;- c(1.8, 1.5, 2.2)  # label sizes
pos &amp;lt;- list(w = rep(0.9, 3), h = rep(0.3, 3), x = c(0.45, 0.6, 0.5), y = c(0.95, 
    0.85, 0.3))
fam &amp;lt;- c(&amp;quot;Impact&amp;quot;, &amp;quot;serif&amp;quot;, &amp;quot;Impact&amp;quot;)
col &amp;lt;- list(c(&amp;quot;black&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;white&amp;quot;), c(&amp;quot;white&amp;quot;, &amp;quot;black&amp;quot;, &amp;quot;black&amp;quot;))
gbg &amp;lt;- list(fill = &amp;quot;#FF00FF50&amp;quot;, col = &amp;quot;#FFFFFF75&amp;quot;)  # graph background

# Save meme
meme(img, lab, &amp;quot;meme.jpg&amp;quot;, size = size, family = fam, col = col[[1]], shadow = col[[2]], 
    label_pos = pos, inset = p, inset_bg = gbg, mult = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p align=&#34;center&#34;&gt;
&lt;img src=&#34;../img/post/meme.jpg&#34;/&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;animated-gif-example&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Animated gif example&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d$grp &amp;lt;- gsub(&amp;quot;Plot&amp;quot;, &amp;quot;Cat&amp;#39;s Plot&amp;quot;, d$grp)
p &amp;lt;- ggplot(d, aes(x, y)) + geom_line(colour = &amp;quot;white&amp;quot;, size = 2) + geom_point(colour = &amp;quot;orange&amp;quot;, 
    size = 1) + facet_wrap(~grp) + labs(title = &amp;quot;The wiggles&amp;quot;, subtitle = &amp;quot;Plots for cats&amp;quot;, 
    caption = &amp;quot;Figure 1. Gimme sine waves.&amp;quot;)
lab &amp;lt;- c(&amp;quot;R plots for cats&amp;quot;, &amp;quot;Sine wave sine wave...&amp;quot;)
pos &amp;lt;- list(w = rep(0.9, 2), h = rep(0.3, 2), x = rep(0.5, 2), y = c(0.9, 0.75))
img &amp;lt;- &amp;quot;http://forgifs.com/gallery/d/228621-4/Cat-wiggles.gif&amp;quot;
meme_gif(img, lab, &amp;quot;sine.gif&amp;quot;, size = c(1.5, 0.75), label_pos = pos, inset = p, 
    inset_bg = list(fill = &amp;quot;#00BFFF80&amp;quot;), fps = 20)&lt;/code&gt;&lt;/pre&gt;
&lt;p align=&#34;center&#34;&gt;
&lt;img src=&#34;https://github.com/leonawicz/DataVisExamples/blob/master/packages/memery.gif?raw=true&#34;&gt;
&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Make memorable plots with memery. v0.3.0 now on CRAN.</title>
      <link>/post/2017-11-09-memery-0-3-0-on-cran/</link>
      <pubDate>Thu, 09 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-11-09-memery-0-3-0-on-cran/</guid>
      <description>&lt;p&gt;Make memorable plots with memery. &lt;code&gt;memery&lt;/code&gt; is an R package that generates internet memes including superimposed inset graphs and other atypical features, combining the visual impact of an attention-grabbing meme with graphic results of data analysis. &lt;a href=&#34;https://cran.r-project.org/web/packages/memery/&#34;&gt;Version 0.3.0&lt;/a&gt; of &lt;code&gt;memery&lt;/code&gt; is now on CRAN. The latest development version and a package vignette are available on &lt;a href=&#34;https://github.com/leonawicz/memery&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Below is an example interleaving a semi-transparent ggplot2 graph between a meme image backdrop and overlying meme text labels. The &lt;code&gt;meme&lt;/code&gt; function will produce basic memes without needing to specify a number of additional arguments, but this is not the main purpose of the package. Adding a plot is then as simple as passing the plot to &lt;code&gt;inset&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;memery&lt;/code&gt; offers sensible defaults as well as a variety of basic templates for controlling how the meme and graph are spliced together. The example here shows how additional arguments can be specified to further control the content and layout. See the package &lt;a href=&#34;https://leonawicz.github.io/memery/articles/memery.html&#34;&gt;vignette&lt;/a&gt; for a more complete set of examples and description of available features and graph templates.&lt;/p&gt;
&lt;p&gt;Please do share your data analyst meme creations. Enjoy!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(memery)

# Make a graph of some data
library(ggplot2)
x &amp;lt;- seq(0, 2 * pi, length.out = 50)
panels &amp;lt;- rep(c(&amp;quot;Plot A&amp;quot;, &amp;quot;Plot B&amp;quot;), each = 50)
d &amp;lt;- data.frame(x = x, y = sin(x), grp = panels)
txt &amp;lt;- c(&amp;quot;Philosoraptor&amp;#39;s plots&amp;quot;, &amp;quot;I like to make plots&amp;quot;, &amp;quot;Figure 1. (A) shows a plot and (B) shows another plot.&amp;quot;)
p &amp;lt;- ggplot(d, aes(x, y)) + geom_line(colour = &amp;quot;cornflowerblue&amp;quot;, size = 2) + 
    geom_point(colour = &amp;quot;orange&amp;quot;, size = 4) + facet_wrap(~grp) + labs(title = txt[1], 
    subtitle = txt[2], caption = txt[3])

# Meme settings
img &amp;lt;- system.file(&amp;quot;philosoraptor.jpg&amp;quot;, package = &amp;quot;memery&amp;quot;)
lab &amp;lt;- c(&amp;quot;What to call my R package?&amp;quot;, &amp;quot;Hmm... What? raptr is taken!?&amp;quot;, &amp;quot;Noooooo!!!!&amp;quot;)
size &amp;lt;- c(1.8, 1.5, 2.2)  # label sizes
pos &amp;lt;- list(w = rep(0.9, 3), h = rep(0.3, 3), x = c(0.45, 0.6, 0.5), y = c(0.95, 
    0.85, 0.3))
fam &amp;lt;- c(&amp;quot;Impact&amp;quot;, &amp;quot;serif&amp;quot;, &amp;quot;Impact&amp;quot;)
col &amp;lt;- list(c(&amp;quot;black&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;white&amp;quot;), c(&amp;quot;white&amp;quot;, &amp;quot;black&amp;quot;, &amp;quot;black&amp;quot;))
gbg &amp;lt;- list(fill = &amp;quot;#FF00FF50&amp;quot;, col = &amp;quot;#FFFFFF75&amp;quot;)  # graph background

# Save meme
meme(img, lab, &amp;quot;meme.jpg&amp;quot;, size = size, family = fam, col = col[[1]], shadow = col[[2]], 
    label_pos = pos, inset = p, inset_bg = gbg, mult = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p align=&#34;center&#34;&gt;
&lt;img src=&#34;../img/post/meme.jpg&#34;/&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>apputils 0.5.0 released</title>
      <link>/post/apputils-0-5-0-released/</link>
      <pubDate>Tue, 24 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/apputils-0-5-0-released/</guid>
      <description>

&lt;p&gt;Version 0.5.0 of the &lt;a href=&#34;https://github.com/leonawicz/apputils&#34; target=&#34;_blank&#34;&gt;apputils&lt;/a&gt; R package has been released on GitHub.
Complete documentation is available at the &lt;a href=&#34;https://leonawicz.github.io/apputils&#34; target=&#34;_blank&#34;&gt;apputils website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The key updates are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Added &lt;code&gt;exApp&lt;/code&gt; for running Shiny app package examples.&lt;/li&gt;
&lt;li&gt;Ported custom icons demo app to &lt;code&gt;apputils&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Included all current custom icons in example app, adding the newer linear model themed icons.&lt;/li&gt;
&lt;li&gt;Added package css for &lt;code&gt;infoBox&lt;/code&gt; override.&lt;/li&gt;
&lt;li&gt;Added introduction vignette content for stat boxes with package icons.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can now call &lt;code&gt;exApp(&amp;quot;icons&amp;quot;)&lt;/code&gt; to view the stat box icons examples locally.
Available icons are grouped into three categories.&lt;/p&gt;

&lt;h3 id=&#34;icons-representing-common-statistics&#34;&gt;Icons representing common statistics&lt;/h3&gt;

&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;../img/post/apputils_vbox1.png&#34;/&gt;&lt;/p&gt;

&lt;h3 id=&#34;icons-representing-delta-change-or-trends&#34;&gt;Icons representing delta change or trends&lt;/h3&gt;

&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;../img/post/apputils_vbox2.png&#34;/&gt;&lt;/p&gt;

&lt;h3 id=&#34;icons-related-to-fitting-statistical-models&#34;&gt;Icons related to fitting statistical models&lt;/h3&gt;

&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;../img/post/apputils_vbox3.png&#34;/&gt;&lt;/p&gt;

&lt;p&gt;These are the recent updates to &lt;code&gt;apputils&lt;/code&gt;. However, the package offers other helpful utilities such as convenient functions for:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;app citation&lt;/li&gt;
&lt;li&gt;a showcase widget for displaying and linking to other related apps&lt;/li&gt;
&lt;li&gt;an author/contact info widget&lt;/li&gt;
&lt;li&gt;dashboard sidebar footer logo&lt;/li&gt;
&lt;li&gt;collapsible FAQ widget&lt;/li&gt;
&lt;li&gt;integration with &lt;code&gt;rintrojs&lt;/code&gt; and &lt;code&gt;shinytoastr&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These utilities involve relatively canned styles of presentation so they are not universally suitable for all users and use cases, but they offer convenience when applicable. An example app that uses several utilities from &lt;code&gt;apputils&lt;/code&gt; is my recent work in progress, the SNAP &lt;a href=&#34;https://uasnap.shinyapps.io/climdist/&#34; target=&#34;_blank&#34;&gt;Climate Analytics&lt;/a&gt; app.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Climate explorer update: monthly data and delta change</title>
      <link>/post/climate-explorer-update-monthly-data-and-delta-change/</link>
      <pubDate>Mon, 23 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/climate-explorer-update-monthly-data-and-delta-change/</guid>
      <description>&lt;p&gt;The SNAP &lt;a href=&#34;https://uasnap.shinyapps.io/climdist/&#34; target=&#34;_blank&#34;&gt;Climate Analytics&lt;/a&gt; Shiny app has been updated.
Previously, the app included seasonally and annually aggregated data.
With the recent inclusion of monthly data, the number of conditional spatio-temporal climate probability distributions has now increased from a base set of about 13 million unique distributions to over 46 million. The &lt;code&gt;Season&lt;/code&gt; dropdown menu now offers annual average, 3-month seasonals, and individual months.&lt;/p&gt;

&lt;p&gt;These conditional distributions for historical and projected temperature and precipitation over different geographic regions, time periods, climate models and greenhouse gas emissions scenarios represent the source data sets available in the app. This count does not include the marginal distributions users can estimate on the fly while using the app. For example, you can look at annual probability distributions for five different climate models, but while this may be of interest in some cases, in others it may be more interesting to to investigate the spatial distribution of temperature for a multi-model composite over some aggregate time period. This is where the app really shines; not in the large number of available conditional distributions, but rather in providing real-time estimation of marginal distributions of interest to users.&lt;/p&gt;

&lt;p&gt;The other major change is the ability to convert figures and statistics to reflect projected delta change (anomalies) in comparison with a historical climatology period.
The new option can be found in the &lt;code&gt;Additional settings&lt;/code&gt; modal.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;../img/post/climdist_climatology.png&#34;/&gt;&lt;/p&gt;

&lt;p&gt;In this example, the data selection is as shown here.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;../img/post/climdist_data.png&#34;/&gt;&lt;/p&gt;

&lt;p&gt;By default, raw climate values are shown, e.g., a time series of temperature values.
This is unchanged from before.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;../img/post/climdist_ts1.png&#34;/&gt;&lt;/p&gt;

&lt;p&gt;When the delta change option is checked, plots and statistics update to reflect change vs. historical baseline average.
Climatologies use CRU 4.0 data. The period can range anywhere from 1950 - 2009, defaulting the the 1980 - 2009 30-year climatology.
Climatologies are unique to each geographic region and seasonal period.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;../img/post/climdist_ts2.png&#34;/&gt;&lt;/p&gt;

&lt;p&gt;As you can see above, some comparisons of change over time are easier to glean from the plot when viewing delta change instead of raw values.
Also note that temperature deltas or anomalies are differential whereas change in precipitation is proportional.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Shiny app: Distributions of random variables</title>
      <link>/post/shiny-app-distributions-of-random-variables/</link>
      <pubDate>Thu, 12 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/shiny-app-distributions-of-random-variables/</guid>
      <description>&lt;p&gt;There is a new version of my &lt;a href=&#34;https://uasnap.shinyapps.io/rvdist/&#34; target=&#34;_blank&#34;&gt;Distributions of Random Variables&lt;/a&gt; Shiny app available.
This is a cleaned up modern revision of my original 2013 app series involving random variable probability distributions.
The primary change is a switch to &lt;code&gt;ggplot2&lt;/code&gt; from base graphics. I have added this app to my &lt;a href=&#34;https://github.com/ua-snap/shiny-apps&#34; target=&#34;_blank&#34;&gt;shiny-apps&lt;/a&gt; GitHub repository so the source code is available, including a script containing all those pesky &lt;code&gt;plotmath&lt;/code&gt; expressions.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;../img/post/rvdist.png&#34;/&gt;&lt;/p&gt;

&lt;p&gt;The app draws and plots samples from various well known discrete and continuous probability distributions, all of which are available in base R with the single exception of the Pareto distribution. To include this distribution, I used the &lt;code&gt;VGAM&lt;/code&gt; package. The plots include an overlay of the formula for the selected probability mass or density function.&lt;/p&gt;

&lt;p&gt;Available discrete distributions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bernoulli&lt;/li&gt;
&lt;li&gt;Binomial&lt;/li&gt;
&lt;li&gt;Uniform&lt;/li&gt;
&lt;li&gt;Geometric&lt;/li&gt;
&lt;li&gt;Hypergeometric&lt;/li&gt;
&lt;li&gt;Negative Binomial&lt;/li&gt;
&lt;li&gt;Poisson&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Available continuous distributions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Beta&lt;/li&gt;
&lt;li&gt;Cauchy&lt;/li&gt;
&lt;li&gt;Chi-squared&lt;/li&gt;
&lt;li&gt;Exponential&lt;/li&gt;
&lt;li&gt;F&lt;/li&gt;
&lt;li&gt;Gamma&lt;/li&gt;
&lt;li&gt;Laplace (Double Exponential)&lt;/li&gt;
&lt;li&gt;Logistic&lt;/li&gt;
&lt;li&gt;Log-Normal&lt;/li&gt;
&lt;li&gt;Normal&lt;/li&gt;
&lt;li&gt;Pareto&lt;/li&gt;
&lt;li&gt;t&lt;/li&gt;
&lt;li&gt;Uniform&lt;/li&gt;
&lt;li&gt;Weibull&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Assorted Shiny apps collection, full code and data</title>
      <link>/post/2017-04-26-assorted-shiny-apps/</link>
      <pubDate>Wed, 26 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-04-26-assorted-shiny-apps/</guid>
      <description>&lt;p&gt;Here is an &lt;a href=&#34;https://github.com/ua-snap/shiny-apps&#34;&gt;assortment of R Shiny apps&lt;/a&gt; that you may find useful for exploration if you are in the process of learning Shiny and looking for something different. Some of these apps are very small and simple whereas others are large and complex. This repository provides full code and any necessary accompanying data sets. The repo also links to the apps hosted online at shinyapps.io so that you can run apps in your browser without having to download the entire collection repo to run apps locally. That and other details can be found at the repo linked above. This isn’t a tutorial or other form of support, but it’s plenty of R code to peruse if that is what you are looking for.&lt;/p&gt;
&lt;p&gt;A bit of backstory. If I recall correctly, I began exploring RStudio’s Shiny package when I first heard of it in late 2012. Needless to say, a lot has changed since then, including not only all the alpha-release code-breaking changes I had to adjust to when making my first apps and what features and capabilities Shiny has grown to offer, but also simply how I go about coding apps has changed over time symbiotically with the package’s continued development. None of the apps in this repository are quite that old, though a few are close. Even so, they have been maintained and updated and tweaked since then to keep with the times as necessary.&lt;/p&gt;
&lt;p&gt;Most of the apps are newer. But one nice thing about this collection is that it shows a diversity of approaches to coding different features and behavior into apps depending on their purposes and how for me that has changed over time. For example, some apps are heavy on maps. Prior to the robust availability of Leaflet in Shiny, I would tend to have a Shiny app display maps using static (but reactive) plots made with Lattice or ggplot2. There are many ways to do the same thing, and the way that is best in one case is not always the best way.&lt;/p&gt;
&lt;p&gt;Across these apps there are many other examples of different ways to implement the same general task, depending on how I want that to be presented to the user in a specific app. In other cases, some approaches have proven more powerful and outright superior to others and have won out and it is equally useful to see these examples of what once was considered to be “good enough” is no longer.&lt;/p&gt;
&lt;p&gt;Lastly, if you do happen to stumble upon something that is actually broken, I am unaware of it, so please let me know.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Custom images for Shiny dashboard valueBox icons</title>
      <link>/post/custom-images-for-shiny-dashboard-valuebox-icons/</link>
      <pubDate>Wed, 11 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/custom-images-for-shiny-dashboard-valuebox-icons/</guid>
      <description>&lt;p&gt;The &lt;code&gt;shinydashboard&lt;/code&gt; package provides functions like &lt;code&gt;valueBox&lt;/code&gt; that conveniently display basic information like summary statistics. In addition to presenting a value and subtitle on a colored background, an icon may be included as well. However, the icon must come from either the Font Awesome or Glyphicon icon libraries and cannot be image files.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve &lt;a href=&#34;https://gist.github.com/leonawicz/0fab3796b02a62b7f3bd0c02a171f0b7&#34;&gt;provided a gist&lt;/a&gt; that shows how to achieve the use of custom icons with local image files stored in an app&amp;rsquo;s &lt;code&gt;www/&lt;/code&gt; directory. It involves overriding a couple functions in &lt;code&gt;shiny&lt;/code&gt; and &lt;code&gt;shinydashboard&lt;/code&gt; and adding a small bit of custom CSS. Ideally, functionality could be included in future versions of these two packages to allow this in a more robust and complete fashion. But for now, here is a way to do it yourself for value boxes.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;../img/post/valueboxes1.png&#34;&gt;&lt;img src=&#34;../img/post/valueboxes1.png&#34; alt=&#34;valueboxes1&#34; width=&#34;599&#34; height=&#34;351&#34; class=&#34;aligncenter size-full&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The gist above includes the &lt;code&gt;app.R&lt;/code&gt; file to run the &lt;a href=&#34;https://uasnap.shinyapps.io/customiconsdemo/&#34;&gt;Custom Icons Shiny app demo&lt;/a&gt; and the &lt;code&gt;override.R&lt;/code&gt; file which I have it &lt;code&gt;source&lt;/code&gt; separately. The gist also includes an &lt;code&gt;icons.R&lt;/code&gt; script to generate some statistics and probability themed icons from R. This is interesting and fun on its own. This is not needed to run the app, but the icons are of course needed. If you build the app locally you will have to run this script to generate the images and place them in your &lt;code&gt;www/&lt;/code&gt; folder. The live app demo contains them already.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve included both light and dark examples using icons that can be used to generally represent a distribution, mean, standard deviation, minimum, maximum, median or interquartile range. Note that &lt;code&gt;app.R&lt;/code&gt; adds some custom CSS; it is not sufficient to override the definitions of &lt;code&gt;icon&lt;/code&gt; and &lt;code&gt;valueBox&lt;/code&gt; alone. I placed it inline for to reduce the number of required files, but it could alternatively be loaded from a file using &lt;code&gt;includeCSS&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This overriding functionality is only for &lt;code&gt;valueBox&lt;/code&gt; widgets and the way in which a local image file is passed to &lt;code&gt;icon&lt;/code&gt; is with a named list where the available names are &lt;code&gt;src&lt;/code&gt; (required, image file name) and &lt;code&gt;width&lt;/code&gt; (optional, defaults to &lt;code&gt;&#39;100%&#39;&lt;/code&gt;). It is restrictive but demonstrates potential to use image files in place of icon library options without too much code refactoring.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mapmate 0.2.0</title>
      <link>/post/mapmate-0-2-0/</link>
      <pubDate>Tue, 15 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/mapmate-0-2-0/</guid>
      <description>

&lt;p&gt;&lt;em&gt;&lt;code&gt;mapmate&lt;/code&gt; is under development and blog posts can become outdated quickly. Up to date &lt;code&gt;mapmate&lt;/code&gt; documentation and tutorial examples can be found at the &lt;a href=&#34;https://leonawicz.github.io/mapmate/&#34;&gt;official mapmate Github pages&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/leonawicz/mapmate&#34;&gt;mapmate&lt;/a&gt; has now been updating from version 0.1.0 to 0.2.0 on Github. The key change is the incorporation of new functions, help docs and code examples focused on network maps, which is a more complex map type not previously covered. The new tutorial content below provides a a couple basic code examples for making network maps with &lt;code&gt;mapmate&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While &lt;code&gt;mapmate&lt;/code&gt; is aimed at still image sequence generation, allowing the user to exert full control over how still image sequences are used to produce animations subsequently (GUI video editor, ffmpeg, ImageMagick, etc) and not directly at animating from R, the examples here include the use of the &lt;code&gt;animation&lt;/code&gt; package to help you quickly reproduce some basic animated gifs (as long as you have ImageMagick installed on your system). But the takeaway message is that &lt;code&gt;mapmate&lt;/code&gt; now has better support for still image map sequence generation when using the network map type based on great circle arc path traversal.&lt;/p&gt;

&lt;p&gt;If you are new to &lt;code&gt;mapmate&lt;/code&gt; there is also the &lt;a href=&#34;https://leonawicz.github.io/mapmate/mapmate.html&#34;&gt;introductory vignette&lt;/a&gt;. The &lt;a href=&#34;https://leonawicz.github.io/mapmate/networks.html&#34;&gt;content of this post&lt;/a&gt; is available on the &lt;a href=&#34;https://leonawicz.github.io/mapmate/&#34;&gt;mapmate Github pages&lt;/a&gt; as well.&lt;/p&gt;

&lt;p&gt;To install the package:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;devtools::install_github(&amp;quot;leonawicz/mapmate&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;networks&#34;&gt;Networks&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;save_map&lt;/code&gt; function in the &lt;code&gt;mapmate&lt;/code&gt; package offers the &lt;code&gt;type=&amp;quot;network&amp;quot;&lt;/code&gt; map type. This type of map displays networks or pathways defined by overlapping segments traversing along great circle arcs. This map type can be used to display arbitrary line segments as well if such data is provided, but the provided helper functions used here are aimed specifically at drawing great circles.&lt;/p&gt;

&lt;h1 id=&#34;setup&#34;&gt;Setup&lt;/h1&gt;

&lt;h2 id=&#34;obtain-great-circle-arc-endpoints&#34;&gt;Obtain great circle arc endpoints&lt;/h2&gt;

&lt;p&gt;The first example uses a flat map. Therefore it is important to break lines at the international dateline when preparing the data. In the second example, lines cross the dateline are not split because the segments will be plotted on the globe.&lt;/p&gt;

&lt;p&gt;First, begin with the &lt;code&gt;network&lt;/code&gt; data set provided in &lt;code&gt;mapmate&lt;/code&gt; is a simple data frame of lon/lat locations of various cities and corresponding weights related to population sizes. It must be expanded to a larger, more complex data frame that contains location pairs and, optionally, distances between locations in each pair. &lt;code&gt;gc_endpoints&lt;/code&gt; assists with this by simulating some pairs. The resulting data frame contains endpoints of lines that are defined subsequently.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(mapmate)
library(dplyr)

set.seed(192)
data(network)
network

distFun &amp;lt;- function(x) 1 - x/max(x)  # simple inverse distance weighting
endpoints &amp;lt;- gc_endpoints(network, &amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;)
endpoints
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;obtain-great-circle-arcs&#34;&gt;Obtain great circle arcs&lt;/h2&gt;

&lt;p&gt;Next, we sample based on a combination of weights. This is an arbitrary and optional step. The example is given primarily to make the data set used in these examples smaller in size. More importantly, the &lt;code&gt;gc_arcs&lt;/code&gt; helper function is used to further expand the &lt;code&gt;endpoints&lt;/code&gt; data frame to one containing sequences of points describing great circle arcs instead of only their endpoints.&lt;/p&gt;

&lt;p&gt;The default number of points added between the endpoints of each great circle arc is &lt;code&gt;n=50&lt;/code&gt;, but this can be changed and can also differ for each arc (e.g., based on distance between points). As noted, arcs are filled out planning for use with both flat maps and a globes. A &lt;code&gt;group&lt;/code&gt; column is used to identify distinct arcs for plotting.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# take a weighted sample, e.g., favoring larger averaged populations and
# shorter distances
endpoints &amp;lt;- mutate(endpoints, Dist_wts = distFun(Dist))
endpoints &amp;lt;- sample_n(endpoints, 500, replace = TRUE, weight = (Pop_wts0 + Pop_wts1)/2 + 
    Dist_wts)

# expand data frame from endpoints to arcs, each composed of a sequence of
# points
arcs_flat &amp;lt;- gc_arcs(endpoints, &amp;quot;lon0&amp;quot;, &amp;quot;lat0&amp;quot;, &amp;quot;lon1&amp;quot;, &amp;quot;lat1&amp;quot;, breakAtDateLine = TRUE)
arcs_globe &amp;lt;- gc_arcs(endpoints, &amp;quot;lon0&amp;quot;, &amp;quot;lat0&amp;quot;, &amp;quot;lon1&amp;quot;, &amp;quot;lat1&amp;quot;)
arcs_globe
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;obtain-great-circle-arc-path-sequences&#34;&gt;Obtain great circle arc path sequences&lt;/h2&gt;

&lt;p&gt;Finally, &lt;code&gt;gc_paths&lt;/code&gt; is used to further expand the great circle arcs data frame into one that contains sequences of ordered segments along each arc. The segments can vary in length between distinct arcs and can overlap one another within an arc. The &lt;code&gt;group&lt;/code&gt; argument is required to identify distinct arcs in the input data frame. &lt;code&gt;size&lt;/code&gt; is required to set an upper limit on the number of points constituting an arc segment; the actual length of the segments is chosen randomly and uniformly between 2 and &lt;code&gt;size&lt;/code&gt;. Other arguments are optional.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;paths_flat &amp;lt;- gc_paths(arcs_flat, &amp;quot;group&amp;quot;, size = 5)
paths_globe &amp;lt;- gc_paths(arcs_globe, &amp;quot;group&amp;quot;, size = 5)
paths_globe
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;flat-map-network-animation&#34;&gt;Flat map network animation&lt;/h1&gt;

&lt;p&gt;The direction of arc traversal can also be controlled by the &lt;code&gt;direction&lt;/code&gt; argument if desired. This is useful for simulations if the input data are not yet randomized or if the directions simply need to be reversed. First some setup:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;n &amp;lt;- max(paths_flat$id)
png.args &amp;lt;- list(width = 600, height = 300, bg = &amp;quot;black&amp;quot;)
clrs &amp;lt;- c(&amp;quot;#1E90FF50&amp;quot;, &amp;quot;#FFFFFF50&amp;quot;, &amp;quot;#FFFFFF&amp;quot;, &amp;quot;#1E90FF75&amp;quot;)
ylm &amp;lt;- range(paths_flat$lat)  # trimming empty southern map region
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Typically, I would leave the default arguments &lt;code&gt;save.plot=TRUE&lt;/code&gt; and &lt;code&gt;return.plot=FALSE&lt;/code&gt;, but here they are reversed for the purposes of the example. This returns a list of &lt;code&gt;ggplot&lt;/code&gt; objects rather than saving png files. Note that I still included the &lt;code&gt;png.args&lt;/code&gt; argument even though &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; will be discarded because &lt;code&gt;save_map&lt;/code&gt; will take the background color specified by &lt;code&gt;bg&lt;/code&gt; intended for png files and use it in the &lt;code&gt;ggplot2&lt;/code&gt; theme applied to the returned plots.&lt;/p&gt;

&lt;p&gt;The default background is transparent so I need to include this here since I have changed it to black. I have changed it to black in this example because I am making a reproducible gif for simplicity rather than doing any layering of separate image sequences in a video editor. Below, &lt;code&gt;saveGIF&lt;/code&gt; from the &lt;code&gt;animation&lt;/code&gt; package is used to make a simple gif from the plot sequence produced by &lt;code&gt;save_map&lt;/code&gt; by looping over the list of returned plots.&lt;/p&gt;

&lt;p&gt;In summary, this is all a somewhat convoluted scenario to show you a short animated gif representing plots made by &lt;code&gt;save_map&lt;/code&gt;. The intended use case for &lt;code&gt;save_map&lt;/code&gt; is to simply export the sequence of png files and the user can do whatever they wish with those files subsequently. If literally all you want to do is make a short, simple animated gif of custom plots using a small amount of data, &lt;em&gt;just use the animation package&lt;/em&gt;. You do not need &lt;code&gt;mapmate&lt;/code&gt; for that. Also, if you are using &lt;code&gt;animation&lt;/code&gt; in general, as with the code below, it is dependent on &lt;code&gt;ImageMagick&lt;/code&gt;, which you will also have to install.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;gglist &amp;lt;- save_seq(paths_flat, id = &amp;quot;id&amp;quot;, n.frames = n, ortho = FALSE, type = &amp;quot;network&amp;quot;, 
    ylim = ylm, suffix = &amp;quot;2D&amp;quot;, png.args = png.args, save.plot = FALSE, return.plot = TRUE)

library(animation)
# you may need to specify a different path on your Windows machine you may
# also need to ensure convert.exe is part of your particular installation
ani.options(convert = &amp;quot;C:/Program Files/ImageMagick-7.0.3-Q16/convert.exe&amp;quot;)
saveGIF(for (i in seq_along(gglist)) print(gglist[[i]]), &amp;quot;network2D.gif&amp;quot;, interval = 1/20, 
    ani.width = 600, ani.height = 300)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;../img/post/network2d.gif&#34;&gt;&lt;img src=&#34;../img/post/network2d.gif?w=774&#34; alt=&#34;network2d&#34; width=&#34;774&#34; height=&#34;387&#34; class=&#34;aligncenter size-large&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This &lt;code&gt;animation&lt;/code&gt;-dependent example and the animated gif are not meant to be distractions from the purpose of this package. Despite the example gif, any code here related to &lt;code&gt;animation&lt;/code&gt; is beyond the scope of this tutorial. If you have trouble running it, see the &lt;code&gt;animation&lt;/code&gt; documentation and just do the following example instead, which is the way &lt;code&gt;mapmate&lt;/code&gt; is meant to be used:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;save_seq(paths_flat, id = &amp;quot;id&amp;quot;, n.frames = n, ortho = FALSE, type = &amp;quot;network&amp;quot;, 
    suffix = &amp;quot;2D&amp;quot;, png.args = png.args)
# Next, do whatever you want with the files, such as import them to a video
# editing program
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;globe-network-animation&#34;&gt;Globe network animation&lt;/h1&gt;

&lt;p&gt;Here is an example plotting network paths along great circle arcs on the globe. Remember that we use the other data set, which was generated with the default &lt;code&gt;breakAtDateline=FALSE&lt;/code&gt; in &lt;code&gt;gc_arcs&lt;/code&gt;. As a side note, if you redo the above example for flat maps using the unbroken data, &lt;code&gt;paths_globe&lt;/code&gt;, you will see why the arc segments are handled differently when preparing data for flat maps vs. for globes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;n &amp;lt;- max(paths_flat$id)
png.args &amp;lt;- list(width = 600, height = 600, bg = &amp;quot;black&amp;quot;)
clrs &amp;lt;- c(&amp;quot;#FFFFFF&amp;quot;, &amp;quot;#FF450050&amp;quot;, &amp;quot;#FF4500&amp;quot;, &amp;quot;#FFFFFF50&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;gglist &amp;lt;- save_seq(paths_globe, id = &amp;quot;id&amp;quot;, n.frames = n, col = clrs, type = &amp;quot;network&amp;quot;, 
    pt.size = c(1, 1, 3, 2), suffix = &amp;quot;3D&amp;quot;, png.args = png.args, save.plot = FALSE, 
    return.plot = TRUE)

library(animation)
ani.options(convert = &amp;quot;C:/Program Files/ImageMagick-7.0.3-Q16/convert.exe&amp;quot;)
saveGIF(for (i in seq_along(gglist)) print(gglist[[i]]), &amp;quot;network3D.gif&amp;quot;, interval = 1/20, 
    ani.width = 600, ani.height = 600)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;../img/post/network3d.gif&#34;&gt;&lt;img src=&#34;../img/post/network3d.gif&#34; alt=&#34;network3d&#34; width=&#34;600&#34; height=&#34;600&#34; class=&#34;aligncenter size-full&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Again, normal usage is to just do the following and then use the saved still image sequence with full user control for whatever you like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;save_seq(paths_globe, id = &amp;quot;id&amp;quot;, n.frames = n, col = clrs, type = &amp;quot;network&amp;quot;, 
    pt.size = c(1, 1, 3, 2), suffix = &amp;quot;3D&amp;quot;, png.args = png.args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here are a few more advanced animations based on still image sequences of great circle arc network maps produced using &lt;code&gt;mapmate&lt;/code&gt; code:&lt;/p&gt;

&lt;h3 id=&#34;historical-and-projected-global-temperature-anomalies&#34;&gt;Historical and projected global temperature anomalies&lt;/h3&gt;

&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;iframe src=&#34;https://www.youtube.com/embed/xhqEkyJDBho?ecver=2&#34; width=&#34;640&#34; height=&#34;360&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h3 id=&#34;global-uaf-snap-shiny-apps-web-traffic&#34;&gt;Global UAF/SNAP Shiny Apps web traffic&lt;/h3&gt;

&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;iframe src=&#34;https://www.youtube.com/embed/uQYR91qixgo?ecver=2&#34; width=&#34;640&#34; height=&#34;360&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h3 id=&#34;flat-map-great-circle-animation-example&#34;&gt;Flat map great circle animation example&lt;/h3&gt;

&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;iframe src=&#34;https://www.youtube.com/embed/yoyIUMvIP3Q?ecver=2&#34; width=&#34;640&#34; height=&#34;360&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h1 id=&#34;mapmate-0-2-0-release-date-2016-11-15&#34;&gt;mapmate 0.2.0 (Release date: 2016-11-15)&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Added functions to assist with network maps: &lt;code&gt;gc_endpoints&lt;/code&gt;, &lt;code&gt;gc_arcs&lt;/code&gt;, and &lt;code&gt;gc_paths&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Added help documentation and runnable examples of the network-related functions.&lt;/li&gt;
&lt;li&gt;Added &lt;code&gt;network&lt;/code&gt; data set to package.&lt;/li&gt;
&lt;li&gt;Added unit tests for network-related functions.&lt;/li&gt;
&lt;li&gt;Added tutorial/examples for network maps to the package Github pages.&lt;/li&gt;
&lt;li&gt;Included simple animated gif examples in above page, piggybacked on &lt;code&gt;animation&lt;/code&gt; package.&lt;/li&gt;
&lt;li&gt;Bug fixes.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>R animation: global climate change</title>
      <link>/post/r-animation-global-climate-change/</link>
      <pubDate>Thu, 29 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/r-animation-global-climate-change/</guid>
      <description>&lt;p&gt;I have posted a new R data animation video. It&amp;rsquo;s an example animation of modeled historical and projected global temperature change from 1850 - 2100. The data prep, analysis, full processing and generation of all sets of still frames for each layer in the video are done using R.&lt;/p&gt;

&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;iframe src=&#34;https://www.youtube.com/embed/xhqEkyJDBho?ecver=2&#34; width=&#34;640&#34; height=&#34;360&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Typically an ensemble of models would be used but this video is just to demonstrate a basic animation using one climate model, both with a monthly time series and a monthly 10-year moving average time series. If wondering about the y-axis range, the animation shows anomalies, or delta change, from the climate model&amp;rsquo;s historical baseline monthly average temperatures using a given climatology window.&lt;/p&gt;

&lt;p&gt;In a later video I will use annual and seasonal averages, which will display a smoother signal than monthly series.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>R animation: global SNAP Shiny app users</title>
      <link>/post/r-animation-global-snap-shiny-app-users/</link>
      <pubDate>Fri, 25 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/r-animation-global-snap-shiny-app-users/</guid>
      <description>&lt;p&gt;For the blog readers, just a quick heads up that I have posted a new R data animation to YouTube. A complete post will follow, but for now here is the video. It displays the social network of SNAP Shiny app users over about the past year and a half using great circle trajectories on a rotating 3D Earth. It&amp;rsquo;s best in 1080p, but still somewhat degraded for streaming. I&amp;rsquo;ll post the raw source video later as well, which is crystal clear.&lt;/p&gt;

&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;iframe src=&#34;https://www.youtube.com/embed/uQYR91qixgo?ecver=2&#34; width=&#34;640&#34; height=&#34;360&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;I used geolocation data from Google Analytics. I routed all the traffic randomly through either Fairbanks, AK or Denver, CO to complete the network since those two places best describe where my apps come from. It&amp;rsquo;s great to see how many people connect to the apps and from where; too many people to plot as a single static graphic without some of the essence of the data being lost.&lt;/p&gt;

&lt;p&gt;As usual, the still frames of the rotating globe, its surface texture, country boundaries and great circle paths are all made in R. It&amp;rsquo;s basically a series of plots made with ggplot2.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>R animation: great circles 3, final draft</title>
      <link>/post/r-animation-great-circles-3/</link>
      <pubDate>Fri, 04 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/r-animation-great-circles-3/</guid>
      <description>&lt;p&gt;Here is the final draft of my great circle arcs R animation. I made this back in January shortly after my first two drafts, but am only now getting around to sharing it, which is a typical representation of how seldom I can make time for blogging. But given the recent spike in interest (thanks to &lt;a href=&#34;http://urbandemographics.blogspot.co.uk/2015/08/data-visualization-with-r-geographic.html&#34; target=&#34;_blank&#34;&gt;Urban Demographics&lt;/a&gt; for sharing my work) in the first, and roughest, draft, I am motivated to finally share something better.&lt;/p&gt;

&lt;p&gt;As with &lt;a href=&#34;http://blog.snap.uaf.edu/2015/03/04/animated-great-circles-1-flat-map-to-3d-earth/&#34; title=&#34;Animated great circles 1: flat map to 3D Earth&#34;&gt;DRAFT 1&lt;/a&gt; and &lt;a href=&#34;http://blog.snap.uaf.edu/2015/04/16/animated-great-circles-2-smoother-lines/&#34; title=&#34;Animated great circles 2: smoother lines&#34;&gt;DRAFT 2&lt;/a&gt;, the YouTube video upload is of significantly reduced quality compared to the original render. As I&amp;rsquo;ve said in the previous posts, it&amp;rsquo;s really not even worth watching on YouTube.&lt;/p&gt;

&lt;p&gt;A much higher quality &lt;a href=&#34;https://www.snap.uaf.edu/webshared/leonawicz/video/geonet_seq3.zip&#34;&gt;source video is available here&lt;/a&gt;. It can be downloaded (~365 MB) and viewed locally using a standard video player such as VLC. Here is a screenshot taken from source as an example:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;../img/post/datavis_r_geonet3.jpg&#34;&gt;&lt;img src=&#34;../img/post/datavis_r_geonet3.jpg?w=774&#34; alt=&#34;datavis_R_geonet3&#34; width=&#34;774&#34; height=&#34;424&#34; class=&#34;aligncenter size-large&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The previous posts describe the issues with video streaming sites compressing videos for steaming and how this will not noticeably degrade most videos, but my great circle animations (particularly this one) have many tiny rapidly moving lines and subtle color and transparency changes; i.e., the perfect candidate videos for being severely degraded by re-encoding, with too much information being tossed out from frame to frame for streaming purposes. In fact, despite being my final draft, this video may ironically display more poorly on YouTube since it contains so many more elements in motion and frame-to-frame pixel changes than my first two drafts, while being far superior in quality when viewing the source video.&lt;/p&gt;

&lt;p&gt;I am quite pleasantly surprised at the video quality on YouTube (1080p, full screen mode) at the beginning of the video. Perhaps this is because there are only 1,000 lines at first and they do not move quite as fast as in my previous videos. Furthermore, being shorter in length, their movement on the screen involves fewer pixel changes from frame to frame. There may be occasional stutter or moments of blurriness during streaming but overall not too bad with a good connection. As I expected, however, later in the video as I increment the number of great circle pathways simultaneously on the screen to over 10,000, the quality degrades significantly.&lt;/p&gt;

&lt;p&gt;Here is the YouTube version if you must:&lt;/p&gt;

&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;iframe src=&#34;https://www.youtube.com/embed/yoyIUMvIP3Q?ecver=2&#34; width=&#34;640&#34; height=&#34;360&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;In addition to my great circle path traversal animation, this video also incorporates a layer of my gridded path traversal in places. See &lt;a href=&#34;http://blog.snap.uaf.edu/2015/02/06/animated-gridded-paths-in-r/&#34;&gt;Animated gridded paths in R&lt;/a&gt; for a description and video example of this process.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.snap.uaf.edu/2015/04/14/animated-paths-in-r-toy-example/&#34; title=&#34;Animated paths in R: toy example&#34;&gt;This post&lt;/a&gt; explains one way to animate basic path traversal in R using a toy code example. Please read this before inquiring about source code. It explains how the basic concept is easy to implement for your data and provides template code, but the resources and computing environment I used to produce the frames for these videos makes the specific code I used not reproducible.&lt;/p&gt;

&lt;p&gt;There is nothing special about the code that will make it magically perfectly scalable. That&amp;rsquo;s where you have to provide your own ingenuity to deal with your data. For example, few people are going to want to use or have access to the &lt;code&gt;Rmpi&lt;/code&gt; package on a multi-node Linux cluster to speed up the process. Depending on your data, you would have to find your own ways of dealing with the sheer resource overhead you may create. Believe it or not, the gridded paths can be much more resource intensive (RAM, CPUs, and/or time, pick your poison) to produce quality animations than great circles. This is because sometimes displaying movement of line segments along gridded paths requires segments which are defined by longer vectors of more closely spaced points in order to &amp;ldquo;turn corners&amp;rdquo; nicely.&lt;/p&gt;

&lt;p&gt;Also, recall from previous posts that I am using R to make still frames and I then dump the image sequence onto a timeline in a movie editing program to render the video. There are R packages like &lt;code&gt;animation&lt;/code&gt; which can abstract the entire process for you, but it isn&amp;rsquo;t meant for something as large as this video. Besides, it just makes sense to use R for statistically and mathematically defined data plotting and animation sequences and use a video rendering program for finishing touches and rendering to mp4 format. Do what makes the most sense with each piece of software.&lt;/p&gt;

&lt;p&gt;Lastly, credit obviously to John Tukey for the &amp;ldquo;Tukey tally&amp;rdquo; 30-point countdown visual I made for the beginning of the video. While perhaps not the most interesting, that code is short, simple, and shareable so I will just dump it here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Tukey tally plot sequence
tukeyTally &amp;lt;- function(i, ...){
  stopifnot(as.numeric(i) &amp;amp;&amp;amp; i %in% 1:10)
  par(mai=c(0,0,0,0))
  plot(0, 0, type=&amp;quot;n&amp;quot;, axes=F, xlab=&amp;quot;&amp;quot;, ylab=&amp;quot;&amp;quot;, xlim=c(0, 1), ylim=c(0, 1))
  m &amp;lt;- matrix(c(0,1,1,0,1,1,0,0), nrow=4)

  if(i&amp;gt;=5) segments(m[1,1], m[1,2], m[2,1], m[2,2], ...)
  if(i&amp;gt;=6) segments(m[2,1], m[2,2], m[3,1], m[3,2], ...)
  if(i&amp;gt;=7) segments(m[4,1], m[4,2], m[3,1], m[3,2], ...)
  if(i&amp;gt;=8) segments(m[1,1], m[1,2], m[4,1], m[4,2], ...)
  if(i&amp;gt;=9) segments(m[1,1], m[1,2], m[3,1], m[3,2], ...)
  if(i==10) segments(m[4,1], m[4,2], m[2,1], m[2,2], ...)

  points(m[1,1], m[1,2], ...)
  if(i&amp;gt;=2) points(m[2,1], m[2,2], ...)
  if(i&amp;gt;=3) points(m[3,1], m[3,2], ...)
  if(i&amp;gt;=4) points(m[4,1], m[4,2], ...)
}

dir.create(outDir &amp;lt;- &amp;quot;C:/leonawicz/GlobalNetworks/plots/frames/tukey_ticker_10to1&amp;quot;, showWarnings=FALSE)
for(i in 1:10){
  png(paste0(outDir, &amp;quot;/tukey_ticker_10to1_frame&amp;quot;, 10-i, &amp;quot;.png&amp;quot;), bg=&amp;quot;transparent&amp;quot;)
  tukeyTally(i, lwd=10,  pch=19, cex=4, col=&amp;quot;greenyellow&amp;quot;)
  dev.off()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may be wondering how this can be a &amp;ldquo;final&amp;rdquo; draft. The obvious next step is to reproduce this video projected onto a 3D rotating earth, right!? Believe me, I have thought about it. That would take a good deal more work. As I explained in the post for the first draft, the only one to feature great circle lines on a spinning globe, resource issues makes it orders of magnitude more challenging, and this 2D flat map video is already far more complex than the original draft. Perhaps later I will take this on. In the meantime enjoy the video.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
